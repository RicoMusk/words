import proguard.gradle.ProGuardTask

buildscript {
    repositories {
        mavenCentral()
        google()
    }
    dependencies {
        classpath 'com.guardsquare:proguard-gradle:7.3.0'
    }
}

plugins {
    id 'java'
    id 'org.springframework.boot' version '2.7.3'
    id 'io.spring.dependency-management' version '1.0.11.RELEASE'
    id 'java-library'
    id 'maven-publish'
    id 'groovy'
    id "publishing"
}

group = 'com.youland'
version = '1.0.3'
sourceCompatibility = JavaVersion.VERSION_11

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
    maven {
        credentials {
            username '638eb995da874cca72ec2a17'
            password 'PEn47V1nFfw4'
        }
        url 'https://packages.aliyun.com/maven/repository/2310913-release-J7HQKI/'
    }
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    // words
    implementation 'org.apache.poi:poi-ooxml:5.2.2'
    implementation 'org.apache.pdfbox:pdfbox:2.0.27'
    implementation 'com.youland:spiredoc:10.12.3'
    implementation 'com.youland:aspose-words:22.10'
    implementation "org.xhtmlrenderer:flying-saucer-pdf-itext5:9.1.22"
    implementation 'org.jsoup:jsoup:1.15.3'
    implementation 'com.google.guava:guava:31.1-jre'

    // lombok
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

jar {
    enabled = true
}
bootJar {
    enabled = false
}

task extractJar(type: Copy) {
    dependsOn tasks.assemble

    def zipFile = file("${buildDir}/libs/words-${version}-plain.jar")
    def outputDir = file("${buildDir}/extracted/")

    from zipTree(zipFile)
    into outputDir
}

task deleteClasses(type: Delete) {
    delete "${buildDir}/extracted/"
}

task copyObfuscatedClasses(type: Copy) {
    dependsOn tasks.deleteClasses

    from zipTree("${buildDir}/obfuscatedClasses.jar")
    into "${buildDir}/extracted/"
}


task proguard(type: ProGuardTask) {
    dependsOn tasks.extractJar

    injars  "${buildDir}/libs/words-1.0.4-plain.jar"
    outjars "${buildDir}/libs/obfuscatedClasses.jar"

    // As of Java 9, the runtime classes are packaged in modular jmod files.
    libraryjars "${System.getProperty('java.home')}/jmods/java.base.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
    //libraryjars "${System.getProperty('java.home')}/jmods/....."
    dontwarn "java.awt.**"

    // This will contain the Spring dependencies.
    libraryjars sourceSets.main.compileClasspath

    // Save the obfuscation mapping to a file, so we can de-obfuscate any stack
    // traces later on. Keep a fixed source file attribute and all line number
    // tables to get line numbers in the stack traces.
    // You can comment this out if you're not interested in stack traces.
    printmapping 'out.map'
    keepparameternames
    renamesourcefileattribute 'SourceFile'
    keepattributes 'Signature,Exceptions,InnerClasses,PermittedSubclasses,EnclosingMethod,Deprecated,SourceFile,LineNumberTable'

    // Preserve all annotations.
    keepattributes '*Annotation*'

    // Preserve all public classes, and their public and protected fields and
    // methods.
    keep 'public class com.youland.words.model.DocumentHtmlAndFooter { \
        public protected * ; \
    }'
    keep 'public class com.youland.words.core.DocumentConvert { \
        public static ** generateWord(java.util.List) ; \
        public static ** htmlToPdf(java.lang.String) ; \
        public static ** docxToPdf(org.springframework.core.io.ByteArrayResource) ; \
    }'
    // Preserve all native method names and the names of their classes.

    keepclasseswithmembernames includedescriptorclasses: true, 'class * { \
        native <methods>; \
    }'

    // Preserve the special static methods that are required in all enumeration
    // classes.
    keepclassmembers allowoptimization: true, 'enum * { \
        public static **[] values(); \
        public static ** valueOf(java.lang.String); \
    }'


    // Explicitly preserve all serialization members. The Serializable interface
    // is only a marker interface, so it wouldn't save them.
    // You can comment this out if your library doesn't use serialization.
    // If your code contains serializable classes that have to be backward
    // compatible, please refer to the manual.

    keepclassmembers 'class * implements java.io.Serializable { \
        static final long serialVersionUID; \
        static final java.io.ObjectStreamField[] serialPersistentFields; \
        private void writeObject(java.io.ObjectOutputStream); \
        private void readObject(java.io.ObjectInputStream); \
        java.lang.Object writeReplace(); \
        java.lang.Object readResolve(); \
    }'
}

task sourceJar(type: Jar) {
    archiveClassifier = "sources"
}

tasks.named('test') {
    useJUnitPlatform()
}

processResources {
    filesMatching('application.*') {
        expand(project.properties)
    }
}

publishing {
    publications {
        library(MavenPublication) {
            from components.java
        }
    }
    repositories {
        maven {
            url('https://packages.aliyun.com/maven/repository/2310913-release-J7HQKI/')
            credentials({
                username('638eb995da874cca72ec2a17')
                password('PEn47V1nFfw4')
            })
        }
    }
}
